/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./qbdi/frida-qbdi.js":
/*!****************************!*\
  !*** ./qbdi/frida-qbdi.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisType: () => (/* binding */ AnalysisType),\n/* harmony export */   CallbackPriority: () => (/* binding */ CallbackPriority),\n/* harmony export */   ConditionType: () => (/* binding */ ConditionType),\n/* harmony export */   GPR_NAMES: () => (/* binding */ GPR_NAMES),\n/* harmony export */   InstPosition: () => (/* binding */ InstPosition),\n/* harmony export */   InstrRuleDataCBK: () => (/* binding */ InstrRuleDataCBK),\n/* harmony export */   MemoryAccessFlags: () => (/* binding */ MemoryAccessFlags),\n/* harmony export */   MemoryAccessType: () => (/* binding */ MemoryAccessType),\n/* harmony export */   OperandFlag: () => (/* binding */ OperandFlag),\n/* harmony export */   OperandType: () => (/* binding */ OperandType),\n/* harmony export */   Options: () => (/* binding */ Options),\n/* harmony export */   QBDI_MAJOR: () => (/* binding */ QBDI_MAJOR),\n/* harmony export */   QBDI_MINIMUM_VERSION: () => (/* binding */ QBDI_MINIMUM_VERSION),\n/* harmony export */   QBDI_MINOR: () => (/* binding */ QBDI_MINOR),\n/* harmony export */   QBDI_PATCH: () => (/* binding */ QBDI_PATCH),\n/* harmony export */   REG_PC: () => (/* binding */ REG_PC),\n/* harmony export */   REG_RETURN: () => (/* binding */ REG_RETURN),\n/* harmony export */   REG_SP: () => (/* binding */ REG_SP),\n/* harmony export */   RegisterAccessType: () => (/* binding */ RegisterAccessType),\n/* harmony export */   SyncDirection: () => (/* binding */ SyncDirection),\n/* harmony export */   VM: () => (/* binding */ VM),\n/* harmony export */   VMAction: () => (/* binding */ VMAction),\n/* harmony export */   VMError: () => (/* binding */ VMError),\n/* harmony export */   VMEvent: () => (/* binding */ VMEvent),\n/* harmony export */   hexPointer: () => (/* binding */ hexPointer),\n/* harmony export */   rword: () => (/* binding */ rword),\n/* harmony export */   sword: () => (/* binding */ sword)\n/* harmony export */ });\n/*\n * This file is part of QBDI.\n *\n * Copyright 2017 - 2025 Quarkslab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/*\n * Usage:\n * $ frida -n Twitter -l frida-qbdi.js\n *\n */\nvar QBDI_MAJOR = 0;\nvar QBDI_MINOR = 11;\nvar QBDI_PATCH = 0;\n/**\n * Minimum version of QBDI to use Frida bindings\n */\nvar QBDI_MINIMUM_VERSION = (QBDI_MAJOR << 16) | (QBDI_MINOR << 8) | QBDI_PATCH;\n\nif (typeof Duktape === 'object') {\n    // Warn about duktape runtime (except on iOS...)\n    if (Process.platform !== 'darwin' || Process.arch.indexOf(\"arm\") !== 0) {\n        console.warn(\"[!] Warning: using duktape runtime is much slower...\");\n        console.warn(\"    => Frida --enable-jit option should be used\");\n    }\n}\n\n// Provide a generic and \"safe\" (no exceptions if symbol is not found) way to load\n// a library and bind/create a native function\nclass Binder {\n    constructor() { }\n\n    findLibrary(lib, paths) {\n        if (lib === undefined) {\n            return undefined;\n        }\n        var cpath = undefined;\n        if (paths !== undefined) {\n            var cnt = paths.length;\n            var found = false;\n            // try to find our library\n            for (var i = 0; i < cnt; i++) {\n                cpath = paths[i] + lib;\n                // use Frida file interface to test if file exists...\n                try {\n                    var fp = new File(cpath, \"rb\");\n                    fp.close();\n                    found = true;\n                    break;\n                } catch (e) {\n                    continue;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        } else {\n            cpath = lib;\n        }\n        return cpath;\n    }\n\n    safeNativeFunction(cbk, ret, args) {\n        var e = cbk();\n        if (!e) {\n            return undefined;\n        }\n        return new NativeFunction(e, ret, args);\n    }\n\n    load(lib, paths) {\n        var cpath = this.findLibrary(lib, paths);\n        if (cpath === undefined) {\n            var errmsg = lib + ' library not found...';\n            console.error(errmsg);\n            throw new Error(errmsg);\n        }\n        // load library\n        var handle = System.dlopen(cpath);\n        if (handle.isNull()) {\n            var errmsg = 'Failed to load ' + cpath + ' (' + System.dlerror() + ')';\n            console.error(errmsg);\n            throw new Error(errmsg);\n        }\n        return cpath;\n    }\n\n    bind(name, ret, args) {\n        return this.safeNativeFunction(function () {\n            return Module.findGlobalExportByName(name);\n        }, ret, args);\n    }\n}\n\n\nclass QBDIBinder extends Binder {\n    /**\n     * QBDI library name\n     */\n    get QBDI_LIB() {\n        return {\n            'linux': 'libQBDI.so',\n            'darwin': 'libQBDI.dylib',\n            'windows': 'QBDI.dll',\n        }[Process.platform];\n    }\n\n    // paths where QBDI library may be\n    get QBDI_PATHS() {\n        return [\n            // UNIX default paths\n            '/usr/lib/',\n            '/usr/local/lib/',\n            // advised Android path\n            '/data/local/tmp/',\n            // in case of a local archive\n            './',\n            './lib',\n            // Windows default path\n            'C:\\\\Program Files\\\\QBDI ' + QBDI_MAJOR + '.' + QBDI_MINOR + '.' + QBDI_PATCH + '\\\\lib\\\\'\n        ];\n    }\n\n    bind(name, ret, args) {\n        var libpath = this.QBDI_LIB;\n        return this.safeNativeFunction(function () {\n            return Process.getModuleByName(libpath).findExportByName(name);\n        }, ret, args);\n    }\n\n    load() {\n        return super.load(this.QBDI_LIB, this.QBDI_PATHS);\n    }\n}\n\n\nvar _binder = new Binder();\nvar _qbdibinder = new QBDIBinder();\n\n\n// Needed to load QBDI\nvar System_C = Object.freeze({\n    LoadLibraryEx: _binder.bind('LoadLibraryExA', 'pointer', ['pointer', 'int', 'int']),\n    GetLastError: _binder.bind('GetLastError', 'int', []),\n    dlopen: _binder.bind('dlopen', 'pointer', ['pointer', 'int']),\n    dlerror: _binder.bind('dlerror', 'pointer', []),\n    free: _binder.bind('free', 'void', ['pointer']),\n});\n\n\nvar System = Object.freeze({\n    dlerror: function () {\n        if (Process.platform === \"windows\") {\n            var val = System_C.GetLastError();\n            if (val === undefined) {\n                return undefined;\n            }\n            return val.toString();\n        }\n        var strPtr = System_C.dlerror();\n        return strPtr.readCString();\n\n    },\n    dlopen: function (library) {\n        var RTLD_LOCAL = 0x0;\n        var RTLD_LAZY = 0x1;\n        var path = Memory.allocUtf8String(library);\n        if (Process.platform === \"windows\") {\n            return System_C.LoadLibraryEx(path, 0, 0);\n        }\n        return System_C.dlopen(path, RTLD_LOCAL | RTLD_LAZY);\n    },\n    free: function (ptr) {\n        System_C.free(ptr);\n    }\n});\n\n/**\n * Fullpath of the QBDI library\n */\n// Load QBDI library\nvar QBDI_LIB_FULLPATH = _qbdibinder.load();\n\n// Define rword type and interfaces\n\n/**\n * An alias to Frida uint type with the size of general registers (**uint64** or **uint32**)\n */\nvar rword = Process.pointerSize === 8 ? 'uint64' : 'uint32';\nvar sword = Process.pointerSize === 8 ? 'int64' : 'int32';\n\nNativePointer.prototype.readRword = Process.pointerSize === 8 ? NativePointer.prototype.readU64 : NativePointer.prototype.readU32;\nNativePointer.prototype.readSword = Process.pointerSize === 8 ? NativePointer.prototype.readS64 : NativePointer.prototype.readS32;\n\nNativePointer.prototype.writeRword = Process.pointerSize === 8 ? NativePointer.prototype.writeU64 : NativePointer.prototype.writeU32;\nNativePointer.prototype.writeSword = Process.pointerSize === 8 ? NativePointer.prototype.writeS64 : NativePointer.prototype.writeS32;\n\n// Convert a number to its register-sized representation\n\n/**\n * Convert a NativePointer into a type with the size of a register (``Number`` or ``UInt64``).\n */\nNativePointer.prototype.toRword = function () {\n    // Nothing better really ?\n    if (Process.pointerSize === 8) {\n        return uint64(\"0x\" + this.toString(16));\n    }\n    return parseInt(this.toString(16), 16);\n}\n\n/**\n * Convert a number into a type with the size of a register (``Number`` or ``UInt64``).\n * Can't be used for numbers > 32 bits, would cause weird results due to IEEE-754.\n */\nNumber.prototype.toRword = function () {\n    if (this > 0x100000000) {\n        throw new TypeError('For integer > 32 bits, please use Frida uint64 type.');\n    }\n    if (Process.pointerSize === 8) {\n        return uint64(this);\n    }\n    return this;\n}\n\n/**\n * An identity function (returning the same ``UInt64`` object).\n * It exists only to provide a unified **toRword** interface.\n */\nUInt64.prototype.toRword = function () {\n    return this;\n}\n\nInt64.prototype.toSword = function () {\n    return this;\n}\n\n// Some helpers\n\nString.prototype.leftPad = function (paddingValue, paddingLength) {\n    paddingLength = paddingLength || paddingValue.length;\n    if (paddingLength < this.length) {\n        return String(this);\n    }\n    return String(paddingValue + this).slice(-paddingLength);\n};\n\n/**\n * Convert a String into a type with the size of a register (``Number`` or ``UInt64``).\n */\nString.prototype.toRword = function () {\n    return ptr(this).toRword()\n};\n\n/**\n * This function is used to pretty print a pointer, padded with 0 to the size of a register.\n *\n * @param ptr Pointer you want to pad\n *\n * @return pointer value as padded string (ex: \"0x00004242\")\n */\nfunction hexPointer(ptr) {\n    return ptr.toString(16).leftPad(\"0000000000000000\", Process.pointerSize * 2);\n}\n\n\n//\nvar QBDI_C = Object.freeze({\n    // VM\n    initVM: _qbdibinder.bind('qbdi_initVM', 'void', ['pointer', 'pointer', 'pointer', rword]),\n    terminateVM: _qbdibinder.bind('qbdi_terminateVM', 'void', ['pointer']),\n    getOptions: _qbdibinder.bind('qbdi_getOptions', rword, ['pointer']),\n    setOptions: _qbdibinder.bind('qbdi_setOptions', 'void', ['pointer', rword]),\n    addInstrumentedRange: _qbdibinder.bind('qbdi_addInstrumentedRange', 'void', ['pointer', rword, rword]),\n    addInstrumentedModule: _qbdibinder.bind('qbdi_addInstrumentedModule', 'uchar', ['pointer', 'pointer']),\n    addInstrumentedModuleFromAddr: _qbdibinder.bind('qbdi_addInstrumentedModuleFromAddr', 'uchar', ['pointer', rword]),\n    instrumentAllExecutableMaps: _qbdibinder.bind('qbdi_instrumentAllExecutableMaps', 'uchar', ['pointer']),\n    removeInstrumentedRange: _qbdibinder.bind('qbdi_removeInstrumentedRange', 'void', ['pointer', rword, rword]),\n    removeInstrumentedModule: _qbdibinder.bind('qbdi_removeInstrumentedModule', 'uchar', ['pointer', 'pointer']),\n    removeInstrumentedModuleFromAddr: _qbdibinder.bind('qbdi_removeInstrumentedModuleFromAddr', 'uchar', ['pointer', rword]),\n    removeAllInstrumentedRanges: _qbdibinder.bind('qbdi_removeAllInstrumentedRanges', 'void', ['pointer']),\n    run: _qbdibinder.bind('qbdi_run', 'uchar', ['pointer', rword, rword]),\n    call: _qbdibinder.bind('qbdi_call', 'uchar', ['pointer', 'pointer', rword, 'uint32',\n        '...', rword, rword, rword, rword, rword, rword, rword, rword, rword, rword]),\n    switchStackAndCall: _qbdibinder.bind('qbdi_switchStackAndCall', 'uchar', ['pointer', 'pointer', rword, 'uint32', 'uint32',\n        '...', rword, rword, rword, rword, rword, rword, rword, rword, rword, rword]),\n    getGPRState: _qbdibinder.bind('qbdi_getGPRState', 'pointer', ['pointer']),\n    getFPRState: _qbdibinder.bind('qbdi_getFPRState', 'pointer', ['pointer']),\n    getErrno: _qbdibinder.bind('qbdi_getErrno', 'uint32', ['pointer']),\n    setGPRState: _qbdibinder.bind('qbdi_setGPRState', 'void', ['pointer', 'pointer']),\n    setFPRState: _qbdibinder.bind('qbdi_setFPRState', 'void', ['pointer', 'pointer']),\n    setErrno: _qbdibinder.bind('qbdi_setErrno', 'void', ['pointer', 'uint32']),\n    addMnemonicCB: _qbdibinder.bind('qbdi_addMnemonicCB', 'uint32', ['pointer', 'pointer', 'uint32', 'pointer', 'pointer', 'int32']),\n    addMemAccessCB: _qbdibinder.bind('qbdi_addMemAccessCB', 'uint32', ['pointer', 'uint32', 'pointer', 'pointer', 'int32']),\n    addInstrRule: _qbdibinder.bind('qbdi_addInstrRule', 'uint32', ['pointer', 'pointer', 'uint32', 'pointer']),\n    addInstrRuleRange: _qbdibinder.bind('qbdi_addInstrRuleRange', 'uint32', ['pointer', rword, rword, 'pointer', 'uint32', 'pointer']),\n    addInstrRuleData: _qbdibinder.bind('qbdi_addInstrRuleData', 'void', ['pointer', 'uint32', 'pointer', 'pointer', 'int32']),\n    addMemAddrCB: _qbdibinder.bind('qbdi_addMemAddrCB', 'uint32', ['pointer', rword, 'uint32', 'pointer', 'pointer']),\n    addMemRangeCB: _qbdibinder.bind('qbdi_addMemRangeCB', 'uint32', ['pointer', rword, rword, 'uint32', 'pointer', 'pointer']),\n    addCodeCB: _qbdibinder.bind('qbdi_addCodeCB', 'uint32', ['pointer', 'uint32', 'pointer', 'pointer', 'int32']),\n    addCodeAddrCB: _qbdibinder.bind('qbdi_addCodeAddrCB', 'uint32', ['pointer', rword, 'uint32', 'pointer', 'pointer', 'int32']),\n    addCodeRangeCB: _qbdibinder.bind('qbdi_addCodeRangeCB', 'uint32', ['pointer', rword, rword, 'uint32', 'pointer', 'pointer', 'int32']),\n    addVMEventCB: _qbdibinder.bind('qbdi_addVMEventCB', 'uint32', ['pointer', 'uint32', 'pointer', 'pointer']),\n    deleteInstrumentation: _qbdibinder.bind('qbdi_deleteInstrumentation', 'uchar', ['pointer', 'uint32']),\n    deleteAllInstrumentations: _qbdibinder.bind('qbdi_deleteAllInstrumentations', 'void', ['pointer']),\n    getInstAnalysis: _qbdibinder.bind('qbdi_getInstAnalysis', 'pointer', ['pointer', 'uint32']),\n    getCachedInstAnalysis: _qbdibinder.bind('qbdi_getCachedInstAnalysis', 'pointer', ['pointer', rword, 'uint32']),\n    getJITInstAnalysis: _qbdibinder.bind('qbdi_getJITInstAnalysis', 'pointer', ['pointer', rword, 'uint32']),\n    recordMemoryAccess: _qbdibinder.bind('qbdi_recordMemoryAccess', 'uchar', ['pointer', 'uint32']),\n    getInstMemoryAccess: _qbdibinder.bind('qbdi_getInstMemoryAccess', 'pointer', ['pointer', 'pointer']),\n    getBBMemoryAccess: _qbdibinder.bind('qbdi_getBBMemoryAccess', 'pointer', ['pointer', 'pointer']),\n    // Memory\n    allocateVirtualStack: _qbdibinder.bind('qbdi_allocateVirtualStack', 'uchar', ['pointer', 'uint32', 'pointer']),\n    alignedAlloc: _qbdibinder.bind('qbdi_alignedAlloc', 'pointer', ['uint32', 'uint32']),\n    alignedFree: _qbdibinder.bind('qbdi_alignedFree', 'void', ['pointer']),\n    simulateCall: _qbdibinder.bind('qbdi_simulateCall', 'void', ['pointer', rword, 'uint32',\n        '...', rword, rword, rword, rword, rword, rword, rword, rword, rword, rword]),\n    getModuleNames: _qbdibinder.bind('qbdi_getModuleNames', 'pointer', ['pointer']),\n    // Logs\n    setLogPriority: _qbdibinder.bind('qbdi_setLogPriority', 'void', ['uint32']),\n    // Helpers\n    getVersion: _qbdibinder.bind('qbdi_getVersion', 'pointer', ['pointer']),\n    getGPR: _qbdibinder.bind('qbdi_getGPR', rword, ['pointer', 'uint32']),\n    setGPR: _qbdibinder.bind('qbdi_setGPR', 'void', ['pointer', 'uint32', rword]),\n    getMemoryAccessStructDesc: _qbdibinder.bind('qbdi_getMemoryAccessStructDesc', 'pointer', []),\n    getVMStateStructDesc: _qbdibinder.bind('qbdi_getVMStateStructDesc', 'pointer', []),\n    getOperandAnalysisStructDesc: _qbdibinder.bind('qbdi_getOperandAnalysisStructDesc', 'pointer', []),\n    getInstAnalysisStructDesc: _qbdibinder.bind('qbdi_getInstAnalysisStructDesc', 'pointer', []),\n    precacheBasicBlock: _qbdibinder.bind('qbdi_precacheBasicBlock', 'uchar', ['pointer', rword]),\n    clearCache: _qbdibinder.bind('qbdi_clearCache', 'void', ['pointer', rword, rword]),\n    clearAllCache: _qbdibinder.bind('qbdi_clearAllCache', 'void', ['pointer']),\n    getNbExecBlock: _qbdibinder.bind('qbdi_getNbExecBlock', 'uint32', ['pointer']),\n    reduceCacheTo: _qbdibinder.bind('qbdi_reduceCacheTo', 'void', ['pointer', 'uint32']),\n});\n\n// Init some globals\nif (Process.arch === 'x64') {\n    var GPR_NAMES_ = [\"RAX\", \"RBX\", \"RCX\", \"RDX\", \"RSI\", \"RDI\", \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\", \"RBP\", \"RSP\", \"RIP\", \"EFLAGS\", \"FS\", \"GS\"];\n    var REG_RETURN_ = \"RAX\";\n    var REG_PC_ = \"RIP\";\n    var REG_SP_ = \"RSP\";\n} else if (Process.arch === 'arm64') {\n    var GPR_NAMES_ = [\"X0\", \"X1\", \"X2\", \"X3\", \"X4\", \"X5\", \"X6\", \"X7\", \"X8\", \"X9\", \"X10\", \"X11\", \"X12\", \"X13\", \"X14\", \"X15\", \"X16\", \"X17\", \"X18\", \"X19\", \"X20\", \"X21\", \"X22\", \"X23\", \"X24\", \"X25\", \"X26\", \"X27\", \"X28\", \"FP\", \"LR\", \"SP\", \"NZCV\", \"PC\"];\n    var REG_RETURN_ = \"X0\";\n    var REG_PC_ = \"PC\";\n    var REG_SP_ = \"SP\";\n} else if (Process.arch === 'arm') {\n    var GPR_NAMES_ = [\"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"SP\", \"LR\", \"PC\", \"CPSR\"];\n    var REG_RETURN_ = \"R0\";\n    var REG_PC_ = \"PC\";\n    var REG_SP_ = \"SP\";\n} else if (Process.arch === 'ia32') {\n    var GPR_NAMES_ = [\"EAX\", \"EBX\", \"ECX\", \"EDX\", \"ESI\", \"EDI\", \"EBP\", \"ESP\", \"EIP\", \"EFLAGS\"];\n    var REG_RETURN_ = \"EAX\";\n    var REG_PC_ = \"EIP\";\n    var REG_SP_ = \"ESP\";\n}\n\n/**\n * An array holding register names.\n */\nvar GPR_NAMES = GPR_NAMES_;\n/**\n * A constant string representing the register carrying the return value of a function.\n */\nvar REG_RETURN = REG_RETURN_;\n/**\n * String of the instruction pointer register.\n */\nvar REG_PC = REG_PC_;\n/**\n * String of the stack pointer register.\n */\nvar REG_SP = REG_SP_;\n\n/**\n * Error return by the QBDI VM\n *\n * @enum {number}\n * @readonly\n */\nvar VMError = Object.freeze({\n    /**\n     * Returned event is invalid.\n     */\n    INVALID_EVENTID: 0xffffffff\n});\n\n/**\n * Synchronisation direction between Frida and QBDI GPR contexts\n *\n * @enum {number}\n * @readonly\n */\nvar SyncDirection = Object.freeze({\n    /**\n     * Constant variable used to synchronize QBDI's context to Frida's.\n     *\n     * .. warning:: This is currently not supported due to the lack of context updating in Frida.\n     */\n    QBDI_TO_FRIDA: 0,\n    /**\n     * Constant variable used to synchronize Frida's context to QBDI's.\n     */\n    FRIDA_TO_QBDI: 1\n});\n\n/**\n * The callback results.\n *\n * @enum {number}\n * @readonly\n */\nvar VMAction = Object.freeze({\n    /**\n     * The execution of the basic block continues.\n     */\n    CONTINUE: 0,\n    /**\n     * Available only with PREINST InstCallback.  The instruction and the\n     * remained PREINST callbacks are skip. The execution continue with the\n     * POSTINST instruction.\n     *\n     * We recommand to used this result with a low priority PREINST callback in\n     * order to emulate the instruction without skipping the POSTINST callback.\n     */\n    SKIP_INST: 1,\n    /*!*\n     * Available only with InstCallback. The current instruction and the\n     * reminding callback (PRE and POST) are skip. The execution continues to\n     * the next instruction.\n     *\n     * For instruction that change the instruction pointer (jump/call/ret),\n     * BREAK_TO_VM must be used insted of SKIP.\n     *\n     * SKIP can break the record of MemoryAccess for the current instruction.\n     */\n    SKIP_PATCH: 2,\n    /**\n     * The execution breaks and returns to the VM causing a complete\n     * reevaluation of the execution state. A :js:data:`VMAction.BREAK_TO_VM` is\n     * needed to ensure that modifications of the Program Counter or the program\n     * code are taken into account.\n     */\n    BREAK_TO_VM: 3,\n    /**\n     * Stops the execution of the program. This causes the run function to\n     * return early.\n     */\n    STOP: 4\n});\n\n\n/**\n * Position relative to an instruction.\n *\n * @enum {number}\n * @readonly\n */\nvar InstPosition = Object.freeze({\n    /**\n     * Positioned **before** the instruction.\n     */\n    PREINST: 0,\n    /**\n     * Positioned **after** the instruction.\n     */\n    POSTINST: 1\n});\n\n/**\n * Priority of callback\n *\n * @enum {number}\n * @readonly\n */\nvar CallbackPriority = Object.freeze({\n    /**\n     * Default priority for callback.\n     */\n    PRIORITY_DEFAULT: 0,\n    /**\n     * Maximum priority if getInstMemoryAccess is used in the callback.\n     */\n    PRIORITY_MEMACCESS_LIMIT: 0x1000000\n});\n\n/**\n * Events triggered by the virtual machine.\n *\n * @enum {number}\n * @readonly\n */\nvar VMEvent = Object.freeze({\n    /**\n     * Triggered when the execution enters a sequence.\n     */\n    SEQUENCE_ENTRY: 1,\n    /**\n     * Triggered when the execution exits from the current sequence.\n     */\n    SEQUENCE_EXIT: 1 << 1,\n    /**\n     * Triggered when the execution enters a basic block.\n     */\n    BASIC_BLOCK_ENTRY: 1 << 2,\n    /**\n     * Triggered when the execution exits from the current basic block.\n     */\n    BASIC_BLOCK_EXIT: 1 << 3,\n    /**\n     * Triggered when the execution enters a new (~unknown) basic block.\n     */\n    BASIC_BLOCK_NEW: 1 << 4,\n    /**\n     * Triggered when the ExecBroker executes an execution transfer.\n     */\n    EXEC_TRANSFER_CALL: 1 << 5,\n    /**\n     * Triggered when the ExecBroker returns from an execution transfer.\n     */\n    EXEC_TRANSFER_RETURN: 1 << 6,\n    /**\n     * Not implemented.\n     */\n    SYSCALL_ENTRY: 1 << 7,\n    /**\n     * Not implemented.\n     */\n    SYSCALL_EXIT: 1 << 8,\n    /**\n     * Not implemented.\n     */\n    SIGNAL: 1 << 9\n});\n\n/**\n * Memory access type (read / write / ...)\n *\n * @enum {number}\n * @readonly\n */\nvar MemoryAccessType = Object.freeze({\n    /**\n     * Memory read access.\n     */\n    MEMORY_READ: 1,\n    /**\n     * Memory write access.\n     */\n    MEMORY_WRITE: 2,\n    /**\n     * Memory read/write access.\n     */\n    MEMORY_READ_WRITE: 3\n});\n\n/**\n * Memory access flags\n *\n * @enum {number}\n * @readonly\n */\nvar MemoryAccessFlags = Object.freeze({\n    /**\n     * Empty flag.\n     */\n    MEMORY_NO_FLAGS: 0,\n    /**\n     * The size of the access isn't known.\n     */\n    MEMORY_UNKNOWN_SIZE: 1 << 0,\n    /**\n     * The given size is a minimum size.\n     */\n    MEMORY_MINIMUM_SIZE: 1 << 1,\n    /**\n     * The value of the access is unknown or hasn't been retrived.\n     */\n    MEMORY_UNKNOWN_VALUE: 1 << 2\n});\n\n/**\n * Register access type (read / write / rw)\n *\n * @enum {number}\n * @readonly\n */\nvar RegisterAccessType = Object.freeze({\n    /**\n     * Register is read.\n     */\n    REGISTER_READ: 1,\n    /**\n     * Register is written.\n     */\n    REGISTER_WRITE: 2,\n    /**\n     * Register is read/written.\n     */\n    REGISTER_READ_WRITE: 3\n});\n\n/**\n * Instruction Condition\n *\n * @enum {number}\n * @readonly\n */\nvar ConditionType = Object.freeze({\n    /**\n     * The instruction is unconditionnal\n     */\n    CONDITION_NONE: 0x0,\n    /**\n     * The instruction is always true\n     */\n    CONDITION_ALWAYS: 0x2,\n    /**\n     * The instruction is always false\n     */\n    CONDITION_NEVER: 0x3,\n    /**\n     * Equals ( '==' )\n     */\n    CONDITION_EQUALS: 0x4,\n    /**\n     * Not Equals ( '!=' )\n     */\n    CONDITION_NOT_EQUALS: 0x5,\n    /**\n     * Above ( '>' unsigned )\n     */\n    CONDITION_ABOVE: 0x6,\n    /**\n     * Below or Equals ( '<=' unsigned )\n     */\n    CONDITION_BELOW_EQUALS: 0x7,\n    /**\n     * Above or Equals ( '>=' unsigned )\n     */\n    CONDITION_ABOVE_EQUALS: 0x8,\n    /**\n     * Below ( '<' unsigned )\n     */\n    CONDITION_BELOW: 0x9,\n    /**\n     * Great ( '>' signed )\n     */\n    CONDITION_GREAT: 0xa,\n    /**\n     * Less or Equals ( '<=' signed )\n     */\n    CONDITION_LESS_EQUALS: 0xb,\n    /**\n     * Great or Equals ( '>=' signed )\n     */\n    CONDITION_GREAT_EQUALS: 0xc,\n    /**\n     * Less ( '<' signed )\n     */\n    CONDITION_LESS: 0xd,\n    /**\n     * Even\n     */\n    CONDITION_EVEN: 0xe,\n    /**\n     * Odd\n     */\n    CONDITION_ODD: 0xf,\n    /**\n     * Overflow\n     */\n    CONDITION_OVERFLOW: 0x10,\n    /**\n     * Not Overflow\n     */\n    CONDITION_NOT_OVERFLOW: 0x11,\n    /**\n     * Sign\n     */\n    CONDITION_SIGN: 0x12,\n    /**\n     * Not Sign\n     */\n    CONDITION_NOT_SIGN: 0x13\n});\n\n\n/**\n * Register access type (read / write / rw)\n *\n * @enum {number}\n * @readonly\n */\nvar OperandType = Object.freeze({\n    /**\n     * Invalid operand.\n     */\n    OPERAND_INVALID: 0,\n    /**\n     * Immediate operand.\n     */\n    OPERAND_IMM: 1,\n    /**\n     * General purpose register operand.\n     */\n    OPERAND_GPR: 2,\n    /**\n     * Predicate special operand.\n     */\n    OPERAND_PRED: 3,\n    /**\n     * Float register operand.\n     */\n    OPERAND_FPR: 4,\n    /**\n     * Segment or unsupported register operand\n     */\n    OPERAND_SEG: 5\n});\n\n/**\n * Operand flag\n *\n * @enum {number}\n * @readonly\n */\nvar OperandFlag = Object.freeze({\n    /**\n     * No flag\n     */\n    OPERANDFLAG_NONE: 0,\n    /**\n     * The operand is used to compute an address\n     */\n    OPERANDFLAG_ADDR: 1 << 0,\n    /**\n     * The value of the operand is PC relative\n     */\n    OPERANDFLAG_PCREL: 1 << 1,\n    /**\n     * The operand role isn't fully defined\n     */\n    OPERANDFLAG_UNDEFINED_EFFECT: 1 << 2,\n    /**\n     * The operand is implicit\n     */\n    OPERANDFLAG_IMPLICIT: 1 << 3\n});\n\n/**\n * Properties to retrieve during an instruction analysis.\n *\n * @enum {number}\n * @readonly\n */\nvar AnalysisType = Object.freeze({\n    /**\n     * Instruction analysis (address, mnemonic, ...).\n     */\n    ANALYSIS_INSTRUCTION: 1,\n    /**\n     * Instruction disassembly.\n     */\n    ANALYSIS_DISASSEMBLY: 1 << 1,\n    /**\n     * Instruction operands analysis.\n     */\n    ANALYSIS_OPERANDS: 1 << 2,\n    /**\n     * Instruction nearest symbol (and offset).\n     */\n    ANALYSIS_SYMBOL: 1 << 3,\n    /**\n     * QBDI JIT Information.\n     */\n    ANALYSIS_JIT: 1 << 4\n});\n\n/**\n * QBDI VM Options\n *\n * @enum {number}\n * @readonly\n */\nvar Options = {\n    /**\n     * Default value\n     */\n    NO_OPT: 0,\n    /**\n     * Disable all operation on FPU (SSE, AVX, SIMD).\n     * May break the execution if the target use the FPU.\n     */\n    OPT_DISABLE_FPR: 1 << 0,\n    /**\n     * Disable context switch optimisation when the target\n     * execblock doesn't used FPR.\n     */\n    OPT_DISABLE_OPTIONAL_FPR : 1 << 1,\n    /**\n     * Don't load the value when perform memory access.\n     */\n    OPT_DISABLE_MEMORYACCESS_VALUE : 1 << 2,\n    /**\n     * Don't save and restore errno.\n     */\n    OPT_DISABLE_ERRNO_BACKUP : 1 << 3,\n};\nif (Process.arch === 'x64') {\n    /**\n     * Used the AT&T syntax for instruction disassembly (for X86 and X86_64)\n     */\n    Options.OPT_ATT_SYNTAX = 1 << 24;\n    /**\n     * Enable Backup/Restore of FS/GS segment.\n     * This option uses the instructions (RD|WR)(FS|GS)BASE that must be\n     * supported by the operating system.\n     */\n    Options.OPT_ENABLE_FS_GS = 1 << 25;\n} else if (Process.arch === 'ia32') {\n    Options.OPT_ATT_SYNTAX = 1 << 24;\n} else if (Process.arch === 'arm64') {\n    /**\n     * Disable the emulation of the local monitor by QBDI\n     */\n    Options.OPT_DISABLE_LOCAL_MONITOR = 1 << 24;\n    /**\n     * Disable pointeur authentication\n     */\n    Options.OPT_BYPASS_PAUTH = 1 << 25;\n    /**\n     * Enable BTI on instrumented code\n     */\n    Options.OPT_ENABLE_BTI = 1 << 26;\n} else if (Process.arch === 'arm') {\n    Options.OPT_DISABLE_LOCAL_MONITOR = 1 << 24;\n    /**\n     * Disable the used of D16-D31 register\n     */\n    Options.OPT_DISABLE_D16_D31 = 1 << 25;\n    /**\n     * Change between ARM and Thumb as an ARMv4 CPU\n     */\n    Options.OPT_ARMv4 = 3 << 26;\n    /**\n     * Change between ARM and Thumb as an ARMv5T or ARMv6 CPU\n     */\n    Options.OPT_ARMv5T_6 = 1 << 27;\n    /**\n     * Change between ARM and Thumb as an ARMv7 CPU (default)\n     */\n    Options.OPT_ARMv7 = 0;\n    Options.OPT_ARM_MASK = 3 << 26;\n}\n\nOptions = Object.freeze(Options);\n\nclass InstrRuleDataCBK {\n    /**\n     * Object to define an :js:func:`InstCallback` in an :js:func:`InstrRuleCallback`\n     *\n     * @param {InstPosition} pos       Relative position of the callback (PreInst / PostInst).\n     * @param {InstCallback} cbk       A **native** InstCallback returned by :js:func:`VM.newInstCallback`.\n     * @param {Object|null}       data      User defined data passed to the callback.\n     * @param {Int}          priority  The priority of the callback.\n     */\n    constructor(pos, cbk, data, priority = CallbackPriority.PRIORITY_DEFAULT) {\n        this.position = pos;\n        this.cbk = cbk;\n        this.data = data;\n        this.priority = priority;\n    }\n}\n\nclass State {\n    constructor(state) {\n        if (!NativePointer.prototype.isPrototypeOf(state) || state.isNull()) {\n            throw new TypeError('Invalid state pointer');\n        }\n        this.statePtr = state;\n    }\n\n    get ptr() {\n        return this.statePtr;\n    }\n\n    toRword() {\n        return this.statePtr.toRword();\n    }\n\n    toString() {\n        return this.statePtr.toString();\n    }\n}\n\n/**\n * General Purpose Register context\n */\nclass GPRState extends State {\n    _getGPRId(rid) {\n        if (typeof (rid) === 'string') {\n            rid = GPR_NAMES.indexOf(rid.toUpperCase());\n        }\n        if (rid < 0 || rid > GPR_NAMES.length) {\n            return undefined;\n        }\n        return rid;\n    }\n\n    /**\n     * This function is used to get the value of a specific register.\n     *\n     * @param {String|Number} rid Register (register name or ID can be used e.g : \"RAX\", \"rax\", 0)\n     *\n     * @return GPR value (ex: 0x42)\n     */\n    getRegister(rid) {\n        var rid = this._getGPRId(rid);\n        if (rid === null) {\n            return undefined;\n        }\n        return ptr(QBDI_C.getGPR(this.ptr, rid));\n    }\n\n    /**\n     * This function is used to set the value of a specific register.\n     *\n     * @param {String|Number} rid   Register (register name or ID can be used e.g : \"RAX\", \"rax\", 0)\n     * @param {String|Number} value Register value (use **strings** for big integers)\n     */\n    setRegister(rid, value) {\n        var rid = this._getGPRId(rid);\n        if (rid !== null) {\n            QBDI_C.setGPR(this.ptr, rid, value.toRword());\n        }\n    }\n\n    /**\n     * This function is used to get values of all registers.\n     *\n     * @return GPRs of current context (ex: \\{\"RAX\":0x42, ...\\})\n     */\n    getRegisters() {\n        var regCnt = GPR_NAMES.length;\n        var gprs = {};\n        for (var i = 0; i < regCnt; i++) {\n            gprs[GPR_NAMES[i]] = this.getRegister(i);\n        }\n        return gprs;\n    }\n\n    /**\n     * This function is used to set values of all registers.\n     *\n     * @param gprs Array of register values\n     */\n    setRegisters(gprs) {\n        var regCnt = GPR_NAMES.length;\n        for (var i = 0; i < regCnt; i++) {\n            this.setRegister(i, gprs[GPR_NAMES[i]]);\n        }\n    }\n\n    /**\n     * This function is used to synchronise a specific register between Frida and QBDI.\n     *\n     * .. warning:: Currently QBDI_TO_FRIDA is experimental. (E.G : RIP cannot be synchronized)\n     *\n     * @param                   FridaCtx   Frida context\n     * @param {String|Number}   rid        Register (register name or ID can be used e.g : \"RAX\", \"rax\", 0)\n     * @param {SyncDirection}   direction  Synchronization direction. (:js:data:`FRIDA_TO_QBDI` or :js:data:`QBDI_TO_FRIDA`)\n     */\n    synchronizeRegister(FridaCtx, rid, direction) {\n        if (direction === SyncDirection.FRIDA_TO_QBDI) {\n            this.setRegister(rid, FridaCtx[rid.toLowerCase()].toRword());\n        }\n        else { // FRIDA_TO_QBDI\n            FridaCtx[rid.toLowerCase()] = ptr(this.getRegister(rid).toString());\n        }\n    }\n\n    /**\n     * This function is used to synchronise context between Frida and QBDI.\n     *\n     * .. warning:: Currently QBDI_TO_FRIDA is not implemented (due to Frida limitations).\n     *\n     * @param                   FridaCtx   Frida context\n     * @param {SyncDirection}   direction  Synchronization direction. (:js:data:`FRIDA_TO_QBDI` or :js:data:`QBDI_TO_FRIDA`)\n     */\n    synchronizeContext(FridaCtx, direction) {\n        for (var i in GPR_NAMES) {\n            if (GPR_NAMES[i] === \"EFLAGS\" || GPR_NAMES[i] === \"FS\" || GPR_NAMES[i] === \"GS\") {\n                continue;\n            }\n            this.synchronizeRegister(FridaCtx, GPR_NAMES[i], direction);\n        }\n        if (direction === SyncDirection.QBDI_TO_FRIDA) {\n            throw new Error('Not implemented (does not really work due to Frida)');\n        }\n    }\n\n    /**\n     * Pretty print QBDI context.\n     *\n     * @param {bool} [color] Will print a colored version of the context if set.\n     *\n     * @return dump of all GPRs in a pretty format\n     */\n    pp(color) {\n        var RED = color ? \"\\x1b[31m\" : \"\";\n        var GREEN = color ? \"\\x1b[32m\" : \"\";\n        var RESET = color ? \"\\x1b[0m\" : \"\";\n        var regCnt = GPR_NAMES.length;\n        var regs = this.getRegisters();\n        var line = \"\";\n        for (var i = 0; i < regCnt; i++) {\n            var name = GPR_NAMES[i];\n            if (!(i % 4) && i) {\n                line += '\\n';\n            }\n            line += GREEN; // Will be overwritten by RED if necessary\n            if (name === \"RIP\" | name === \"PC\") {\n                line += RED;\n            }\n            line += name.leftPad(\"    \") + RESET + \"=0x\" + hexPointer(regs[name]) + \" \";\n        }\n        return line;\n    }\n\n    /**\n     * Pretty print and log QBDI context.\n     *\n     * @param {bool} [color] Will print a colored version of the context if set.\n     */\n    dump(color) {\n        console.log(this.pp(color));\n    }\n\n    static validOrThrow(state) {\n        if (!GPRState.prototype.isPrototypeOf(state)) {\n            throw new TypeError('Invalid GPRState');\n        }\n    }\n}\n\n/**\n * Floating Point Register context\n */\nclass FPRState extends State {\n    static validOrThrow(state) {\n        if (!FPRState.prototype.isPrototypeOf(state)) {\n            throw new TypeError('Invalid FPRState');\n        }\n    }\n}\n\nclass VM {\n    // private member\n    #vm = null;\n    #memoryAccessDesc = null;\n    #operandAnalysisStructDesc = null;\n    #instAnalysisStructDesc = null;\n    #vmStateStructDesc = null;\n    #userDataPtrMap = {};\n    #userDataIIdMap = {};\n    #userDataPointer = 0;\n\n    /**\n     * Create a new instrumentation virtual machine using \"**new VM()**\"\n     */\n    constructor() {\n        // Enforce a minimum QBDI version (API compatibility)\n        if (!this.version || this.version.integer < QBDI_MINIMUM_VERSION) {\n            throw new Error('Invalid QBDI version !');\n        }\n\n        // Create VM instance\n        this.#vm = this._initVM();\n\n        // Cache various remote structure descriptions\n        // Parse remote structure descriptions\n        this.#memoryAccessDesc = this._parseStructDesc(QBDI_C.getMemoryAccessStructDesc());\n        this.#operandAnalysisStructDesc = this._parseStructDesc(QBDI_C.getOperandAnalysisStructDesc());\n        this.#instAnalysisStructDesc = this._parseStructDesc(QBDI_C.getInstAnalysisStructDesc());\n        this.#vmStateStructDesc = this._parseStructDesc(QBDI_C.getVMStateStructDesc());\n\n        // add a destructor on garbage collection\n        // The name of the API change with frida 15.0.0\n        if (Number(Frida.version.split(\".\")[0]) < 15) {\n            var that = this;\n            WeakRef.bind(VM, function dispose() {\n                if (that.ptr !== null) {\n                    that._terminateVM(that.ptr);\n                }\n            });\n        } else {\n            var that = this;\n            Script.bindWeak(VM, function dispose() {\n                if (that.ptr !== null) {\n                    that._terminateVM(that.ptr);\n                }\n            });\n        }\n    }\n\n    get ptr() {\n        return this.#vm;\n    }\n\n    /**\n     * QBDI version (major, minor, patch).\n     *\n     * {string:String, integer:Number, major:Number, minor:Number, patch:Number}\n     */\n    get version() {\n        if (!QBDI_C.getVersion) {\n            return undefined;\n        }\n        var version = {};\n        var versionPtr = Memory.alloc(4);\n        var vStrPtr = QBDI_C.getVersion(versionPtr);\n        var vInt = versionPtr.readU32();\n        version.string = vStrPtr.readCString();\n        version.integer = vInt;\n        version.major = (vInt >> 16) & 0xff;\n        version.minor = (vInt >> 8) & 0xff;\n        version.patch = vInt & 0xff;\n        Object.freeze(version);\n        return version;\n    }\n\n    /**\n     * Get the current options of the VM\n     *\n     * @return  {Options}  The current option\n     */\n    getOptions() {\n        return QBDI_C.getOptions(this.#vm);\n    }\n\n    /**\n     * Set the options of the VM\n     *\n     * @param  {Options}  options  The new options of the VM.\n     */\n    setOptions(options) {\n        QBDI_C.setOptions(this.#vm, options);\n    }\n\n    /**\n     * Add an address range to the set of instrumented address ranges.\n     *\n     * @param {String|Number|NativePointer} start  Start address of the range (included).\n     * @param {String|Number|NativePointer} end    End address of the range (excluded).\n     */\n    addInstrumentedRange(start, end) {\n        QBDI_C.addInstrumentedRange(this.#vm, start.toRword(), end.toRword());\n    }\n\n    /**\n     * Add the executable address ranges of a module to the set of instrumented address ranges.\n     *\n     * @param  {String} name   The module's name.\n     *\n     * @return {bool} True if at least one range was added to the instrumented ranges.\n     */\n    addInstrumentedModule(name) {\n        var namePtr = Memory.allocUtf8String(name);\n        return QBDI_C.addInstrumentedModule(this.#vm, namePtr) == true;\n    }\n\n    /**\n     * Add the executable address ranges of a module to the set of instrumented address ranges. using an address belonging to the module.\n     *\n     * @param  {String|Number|NativePointer} addr An address contained by module's range.\n     *\n     * @return {bool} True if at least one range was removed from the instrumented ranges.\n     */\n    addInstrumentedModuleFromAddr(addr) {\n        return QBDI_C.addInstrumentedModuleFromAddr(this.#vm, addr.toRword()) == true;\n    }\n\n    /**\n     * Adds all the executable memory maps to the instrumented range set.\n     *\n     * @return {bool} True if at least one range was added to the instrumented ranges.\n     */\n    instrumentAllExecutableMaps() {\n        return QBDI_C.instrumentAllExecutableMaps(this.#vm) == true;\n    }\n\n    /**\n     * Remove an address range from the set of instrumented address ranges.\n     *\n     * @param {String|Number|NativePointer} start  Start address of the range (included).\n     * @param {String|Number|NativePointer} end    End address of the range (excluded).\n     */\n    removeInstrumentedRange(start, end) {\n        QBDI_C.removeInstrumentedRange(this.#vm, start.toRword(), end.toRword());\n    }\n\n    /**\n     * Remove the executable address ranges of a module from the set of instrumented address ranges.\n     *\n     * @param {String} name   The module's name.\n     *\n     * @return {bool} True if at least one range was added to the instrumented ranges.\n     */\n    removeInstrumentedModule(name) {\n        var namePtr = Memory.allocUtf8String(name);\n        return QBDI_C.removeInstrumentedModule(this.#vm, namePtr) == true;\n    }\n\n    /**\n     * Remove the executable address ranges of a module from the set of instrumented address ranges using an address belonging to the module.\n     *\n     * @param {String|Number|NativePointer} addr: An address contained by module's range.\n     *\n     * @return {bool} True if at least one range was added to the instrumented ranges.\n     */\n    removeInstrumentedModuleFromAddr(addr) {\n        return QBDI_C.removeInstrumentedModuleFromAddr(this.#vm, addr.toRword()) == true;\n    }\n\n    /**\n     * Remove all instrumented ranges.\n     */\n    removeAllInstrumentedRanges() {\n        QBDI_C.removeAllInstrumentedRanges(this.#vm);\n    }\n\n    /**\n     * Start the execution by the DBI from a given address (and stop when another is reached).\n     *\n     * @param {String|Number|NativePointer} start  Address of the first instruction to execute.\n     * @param {String|Number|NativePointer} stop   Stop the execution when this instruction is reached.\n     *\n     * @return {bool} True if at least one block has been executed.\n     */\n    run(start, stop) {\n        return QBDI_C.run(this.#vm, start.toRword(), stop.toRword()) == true;\n    }\n\n    /**\n     * Obtain the current general register state.\n     *\n     * @return {GPRState} An object containing the General Purpose Registers state.\n     */\n    getGPRState() {\n        return new GPRState(QBDI_C.getGPRState(this.#vm));\n    }\n\n    /**\n     * Obtain the current floating point register state.\n     *\n     * @return {FPRState} An object containing the Floating point Purpose Registers state.\n     */\n    getFPRState() {\n        return new FPRState(QBDI_C.getFPRState(this.#vm));\n    }\n\n    /**\n     * Get the backuped value of errno.\n     *\n     * @return {Integer} errno\n     */\n    getErrno() {\n        return QBDI_C.getErrno(this.#vm);\n    }\n\n    /**\n     * Set the GPR state\n     *\n     * @param {GPRState} state  Array of register values\n     */\n    setGPRState(state) {\n        GPRState.validOrThrow(state);\n        QBDI_C.setGPRState(this.#vm, state.ptr);\n    }\n\n    /**\n     * Set the FPR state\n     *\n     * @param {FPRState} state  Array of register values\n     */\n    setFPRState(state) {\n        FPRState.validOrThrow(state);\n        QBDI_C.setFPRState(this.#vm, state.ptr);\n    }\n\n    /**\n     * Set the backuped value of errno\n     *\n     * @param {Integer} errno  the value to set\n     */\n    setErrno(errno) {\n        QBDI_C.setErrno(this.#vm, errno);\n    }\n\n    /**\n     * Pre-cache a known basic block.\n     *\n     * @param {String|Number|NativePointer} pc  Start address of a basic block\n     *\n     * @return {bool} True if basic block has been inserted in cache.\n     */\n    precacheBasicBlock(pc) {\n        return QBDI_C.precacheBasicBlock(this.#vm, pc) == true\n    }\n\n    /**\n     * Clear a specific address range from the translation cache.\n     *\n     * @param {String|Number|NativePointer}  start  Start of the address range to clear from the cache.\n     * @param {String|Number|NativePointer}  end    End of the address range to clear from the cache.\n     */\n    clearCache(start, end) {\n        QBDI_C.clearCache(this.#vm, start, end)\n    }\n\n    /**\n     * Clear the entire translation cache.\n     */\n    clearAllCache() {\n        QBDI_C.clearAllCache(this.#vm)\n    }\n\n    /**\n     * Get the number of ExecBlock in the cache. Each block uses 2 memory pages\n     * and some heap allocations.\n     *\n     * @return {Integer} The number of ExecBlock in the cache.\n     */\n    getNbExecBlock() {\n        return QBDI_C.getNbExecBlock(this.#vm)\n    }\n\n    /** \n     * Reduce the cache to X ExecBlock. Note that this will try to purge the\n     * oldest ExecBlock first, but the block may be recreate if needed by\n     * followed execution.\n     *\n     * @param {Integer} nb The number of BasicBlock that should remains in the\n     *                     cache\n     */\n    reduceCacheTo(nb) {\n        return QBDI_C.reduceCacheTo(this.#vm, nb)\n    }\n\n    /**\n     * Register a callback event if the instruction matches the mnemonic.\n     *\n     * @param {String}       mnem      Mnemonic to match.\n     * @param {InstPosition} pos       Relative position of the callback (PreInst / PostInst).\n     * @param {InstCallback} cbk       A **native** InstCallback returned by :js:func:`VM.newInstCallback`.\n     * @param {Object|null}       data      User defined data passed to the callback.\n     * @param {Int}          priority  The priority of the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addMnemonicCB(mnem, pos, cbk, data, priority = CallbackPriority.PRIORITY_DEFAULT) {\n        var mnemPtr = Memory.allocUtf8String(mnem);\n        var vm = this.#vm;\n        return this._retainUserData(data, function (dataPtr) {\n            return QBDI_C.addMnemonicCB(vm, mnemPtr, pos, cbk, dataPtr, priority);\n        });\n    }\n\n    /**\n     * Register a callback event for every memory access matching the type bitfield made by the instruction in the range codeStart to codeEnd.\n     *\n     * @param {MemoryAccessType} type      A mode bitfield: either MEMORY_READ, MEMORY_WRITE or both (MEMORY_READ_WRITE).\n     * @param {InstCallback}     cbk       A **native** InstCallback returned by :js:func:`VM.newInstCallback`.\n     * @param {Object|null}           data      User defined data passed to the callback.\n     * @param {Int}              priority  The priority of the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addMemAccessCB(type, cbk, data, priority = CallbackPriority.PRIORITY_DEFAULT) {\n        var vm = this.#vm;\n        return this._retainUserData(data, function (dataPtr) {\n            return QBDI_C.addMemAccessCB(vm, type, cbk, dataPtr, priority);\n        });\n    }\n\n    /**\n     * Add a custom instrumentation rule to the VM.\n     *\n     * @param {InstrRuleCallback}  cbk    A **native** InstrRuleCallback returned by :js:func:`VM.newInstrRuleCallback`.\n     * @param {AnalysisType}       type   Analyse type needed for this instruction function pointer to the callback\n     * @param {Object|null}             data   User defined data passed to the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addInstrRule(cbk, type, data) {\n        var vm = this.#vm;\n        return this._retainUserDataForInstrRuleCB(data, function (dataPtr) {\n            return QBDI_C.addInstrRule(vm, cbk, type, dataPtr);\n        });\n    }\n\n    /**\n     * Add a custom instrumentation rule to the VM for a range of address.\n     *\n     * @param {String|Number|NativePointer}      start  Begin of the range of address where apply the rule\n     * @param {String|Number|NativePointer}      end    End of the range of address where apply the rule\n     * @param {InstrRuleCallback}  cbk    A **native** InstrRuleCallback returned by :js:func:`VM.newInstrRuleCallback`.\n     * @param {AnalysisType}       type   Analyse type needed for this instruction function pointer to the callback\n     * @param {Object|null}             data   User defined data passed to the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addInstrRuleRange(start, end, cbk, type, data) {\n        var vm = this.#vm;\n        return this._retainUserDataForInstrRuleCB(data, function (dataPtr) {\n            return QBDI_C.addInstrRuleRange(vm, start.toRword(), end.toRword(), cbk, type, dataPtr);\n        });\n    }\n\n    /**\n     * Add a virtual callback which is triggered for any memory access at a specific address matching the access type.\n     * Virtual callbacks are called via callback forwarding by a gate callback triggered on every memory access. This incurs a high performance cost.\n     *\n     * @param {String|Number|NativePointer}     addr   Code address which will trigger the callback.\n     * @param {MemoryAccessType}  type   A mode bitfield: either MEMORY_READ, MEMORY_WRITE or both (MEMORY_READ_WRITE).\n     * @param {InstCallback}      cbk    A **native** InstCallback returned by :js:func:`VM.newInstCallback`.\n     * @param {Object|null}            data   User defined data passed to the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addMemAddrCB(addr, type, cbk, data) {\n        var vm = this.#vm;\n        return this._retainUserData(data, function (dataPtr) {\n            return QBDI_C.addMemAddrCB(vm, addr.toRword(), type, cbk, dataPtr);\n        });\n    }\n\n    /**\n     * Add a virtual callback which is triggered for any memory access in a specific address range matching the access type.\n     * Virtual callbacks are called via callback forwarding by a gate callback triggered on every memory access. This incurs a high performance cost.\n     *\n     * @param {String|Number|NativePointer}     start    Start of the address range which will trigger the callback.\n     * @param {String|Number|NativePointer}     end      End of the address range which will trigger the callback.\n     * @param {MemoryAccessType}  type     A mode bitfield: either MEMORY_READ, MEMORY_WRITE or both (MEMORY_READ_WRITE).\n     * @param {InstCallback}      cbk      A **native** InstCallback returned by :js:func:`VM.newInstCallback`.\n     * @param {Object|null}            data     User defined data passed to the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addMemRangeCB(start, end, type, cbk, data) {\n        var vm = this.#vm;\n        return this._retainUserData(data, function (dataPtr) {\n            return QBDI_C.addMemRangeCB(vm, start.toRword(), end.toRword(), type, cbk, dataPtr);\n        });\n    }\n\n    /**\n     * Register a callback event for a specific instruction event.\n     *\n     * @param {InstPosition} pos       Relative position of the callback (PreInst / PostInst).\n     * @param {InstCallback} cbk       A **native** InstCallback returned by :js:func:`VM.newInstCallback`.\n     * @param {Object|null}       data      User defined data passed to the callback.\n     * @param {Int}          priority  The priority of the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addCodeCB(pos, cbk, data, priority = CallbackPriority.PRIORITY_DEFAULT) {\n        var vm = this.#vm;\n        return this._retainUserData(data, function (dataPtr) {\n            return QBDI_C.addCodeCB(vm, pos, cbk, dataPtr, priority);\n        });\n    }\n\n    /**\n     * Register a callback for when a specific address is executed.\n     *\n     * @param {String|Number|NativePointer} addr      Code address which will trigger the callback.\n     * @param {InstPosition}  pos       Relative position of the callback (PreInst / PostInst).\n     * @param {InstCallback}  cbk       A **native** InstCallback returned by :js:func:`VM.newInstCallback`.\n     * @param {Object|null}        data      User defined data passed to the callback.\n     * @param {Int}           priority  The priority of the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addCodeAddrCB(addr, pos, cbk, data, priority = CallbackPriority.PRIORITY_DEFAULT) {\n        var vm = this.#vm;\n        return this._retainUserData(data, function (dataPtr) {\n            return QBDI_C.addCodeAddrCB(vm, addr.toRword(), pos, cbk, dataPtr, priority);\n        });\n    }\n\n    /**\n     * Register a callback for when a specific address range is executed.\n     *\n     * @param {String|Number|NativePointer} start     Start of the address range which will trigger the callback.\n     * @param {String|Number|NativePointer} end       End of the address range which will trigger the callback.\n     * @param {InstPosition}  pos       Relative position of the callback (PreInst / PostInst).\n     * @param {InstCallback}  cbk       A **native** InstCallback returned by :js:func:`VM.newInstCallback`.\n     * @param {Object|null}        data      User defined data passed to the callback.\n     * @param {Int}           priority  The priority of the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addCodeRangeCB(start, end, pos, cbk, data, priority = CallbackPriority.PRIORITY_DEFAULT) {\n        var vm = this.#vm;\n        return this._retainUserData(data, function (dataPtr) {\n            return QBDI_C.addCodeRangeCB(vm, start.toRword(), end.toRword(), pos, cbk, dataPtr, priority);\n        });\n    }\n\n    /**\n     * Register a callback event for a specific VM event.\n     *\n     * @param {VMEvent}    mask   A mask of VM event type which will trigger the callback.\n     * @param {VMCallback} cbk    A **native** VMCallback returned by :js:func:`VM.newVMCallback`.\n     * @param {Object|null}     data   User defined data passed to the callback.\n     *\n     * @return {Number} The id of the registered instrumentation (or VMError.INVALID_EVENTID in case of failure).\n     */\n    addVMEventCB(mask, cbk, data) {\n        var vm = this.#vm;\n        return this._retainUserData(data, function (dataPtr) {\n            return QBDI_C.addVMEventCB(vm, mask, cbk, dataPtr);\n        });\n    }\n\n    /**\n     * Remove an instrumentation.\n     *\n     * @param   {Number} id   The id of the instrumentation to remove.\n     * @return  {bool} True if instrumentation has been removed.\n     */\n    deleteInstrumentation(id) {\n        this._releaseUserData(id);\n        return QBDI_C.deleteInstrumentation(this.#vm, id) == true;\n    }\n\n    /**\n     * Remove all the registered instrumentations.\n     */\n    deleteAllInstrumentations() {\n        this._releaseAllUserData();\n        QBDI_C.deleteAllInstrumentations(this.#vm);\n    }\n\n    /**\n     * Obtain the analysis of the current instruction. Analysis results are cached in the VM.\n     * The validity of the returned pointer is only guaranteed until the end of the callback, else a deepcopy of the structure is required.\n     *\n     * @param {AnalysisType} [type] Properties to retrieve during analysis (default to ANALYSIS_INSTRUCTION | ANALYSIS_DISASSEMBLY).\n     *\n     * @return {InstAnalysis} A :js:class:`InstAnalysis` object containing the analysis result.\n     */\n    getInstAnalysis(type) {\n        type = type || (AnalysisType.ANALYSIS_INSTRUCTION | AnalysisType.ANALYSIS_DISASSEMBLY);\n        var analysis = QBDI_C.getInstAnalysis(this.#vm, type);\n        if (analysis.isNull()) {\n            return NULL;\n        }\n        return this._parseInstAnalysis(analysis);\n    }\n\n    /**\n     * Obtain the analysis of a cached instruction. Analysis results are cached in the VM.\n     * The validity of the returned pointer is only guaranteed until the end of the callback, else a deepcopy of the structure is required.\n     *\n     * @param {String|Number|NativePointer} addr    The address of the instruction to analyse.\n     * @param {AnalysisType}  [type]  Properties to retrieve during analysis (default to ANALYSIS_INSTRUCTION | ANALYSIS_DISASSEMBLY).\n     *\n     * @return {InstAnalysis} A :js:class:`InstAnalysis` object containing the analysis result. null if the instruction isn't in the cache.\n     */\n    getCachedInstAnalysis(addr, type) {\n        type = type || (AnalysisType.ANALYSIS_INSTRUCTION | AnalysisType.ANALYSIS_DISASSEMBLY);\n        var analysis = QBDI_C.getCachedInstAnalysis(this.#vm, addr.toRword(), type);\n        if (analysis.isNull()) {\n            return NULL;\n        }\n        return this._parseInstAnalysis(analysis);\n    }\n\n    /**\n     * Obtain the analysis of a JITed instruction. Analysis results are cached\n     * in the VM. The validity of the returned pointer is only guaranteed until\n     * the end of the callback or a call to a noconst method of the VM object.\n     * This API may be used to determine if a given address of the current\n     * process memory correspond to the JIT patch from this VM. Note that this\n     * call may allocate memory.\n     *\n     * @param {String|Number|NativePointer} addr    The JIT address\n     * @param {AnalysisType}  [type]  Properties to retrieve during analysis (default to ANALYSIS_INSTRUCTION | ANALYSIS_DISASSEMBLY).\n     *\n     * @return {InstAnalysis} A :js:class:`InstAnalysis` object containing the analysis result. null if the instruction isn't in the cache.\n     */\n    getJITInstAnalysis(addr, type) {\n        type = type || (AnalysisType.ANALYSIS_INSTRUCTION | AnalysisType.ANALYSIS_DISASSEMBLY | AnalysisType.ANALYSIS_JIT);\n        var analysis = QBDI_C.getJITInstAnalysis(this.#vm, addr.toRword(), type);\n        if (analysis.isNull()) {\n            return NULL;\n        }\n        return this._parseInstAnalysis(analysis);\n    }\n\n    /**\n     * Obtain the memory accesses made by the last executed instruction. Return NULL and a size of 0 if the instruction made no memory access.\n     *\n     * @param {MemoryAccessType} type Memory mode bitfield to activate the logging for: either MEMORY_READ, MEMORY_WRITE or both (MEMORY_READ_WRITE).\n     */\n    recordMemoryAccess(type) {\n        return QBDI_C.recordMemoryAccess(this.#vm, type) == true;\n    }\n\n    /**\n     * Obtain the memory accesses made by the last executed instruction. Return NULL and a size of 0 if the instruction made no memory access.\n     *\n     * @return {MemoryAccess[]} An array of :js:class:`MemoryAccess` made by the instruction.\n     */\n    getInstMemoryAccess() {\n        return this._getMemoryAccess(QBDI_C.getInstMemoryAccess);\n    }\n\n    /**\n     * Obtain the memory accesses made by the last executed sequence. Return NULL and a size of 0 if the basic block made no memory access.\n     *\n     * @return {MemoryAccess[]} An array of :js:class:`MemoryAccess` made by the sequence.\n     */\n    getBBMemoryAccess() {\n        return this._getMemoryAccess(QBDI_C.getBBMemoryAccess);\n    }\n\n    // Memory\n\n    /**\n     * Allocate a new stack and setup the GPRState accordingly. The allocated stack needs to be freed with alignedFree().\n     *\n     * @param {GPRState} state      Array of register values\n     * @param {Number}   stackSize  Size of the stack to be allocated.\n     *\n     * @return  Pointer (rword) to the allocated memory or NULL in case an error was encountered.\n     */\n    allocateVirtualStack(state, stackSize) {\n        GPRState.validOrThrow(state);\n        var stackPtr = Memory.alloc(Process.pointerSize);\n        var ret = QBDI_C.allocateVirtualStack(state.ptr, stackSize, stackPtr);\n        if (ret == false) {\n            return NULL;\n        }\n        return stackPtr.readPointer();\n    }\n\n\n    /**\n     * Allocate a block of memory of a specified sized with an aligned base address.\n     *\n     * @param {Number} size   Allocation size in bytes.\n     * @param {Number} align  Base address alignement in bytes.\n     *\n     * @return  Pointer (rword) to the allocated memory or NULL in case an error was encountered.\n     */\n    alignedAlloc(size, align) {\n        return QBDI_C.alignedAlloc(size, align);\n    }\n\n    /**\n     * Free a block of aligned memory allocated with alignedAlloc or allocateVirtualStack\n     *\n     * @param {NativePtr} ptr  Pointer to the allocated memory.\n     */\n    alignedFree(ptr) {\n        QBDI_C.alignedFree(ptr);\n    }\n\n    /**\n     * Simulate a call by modifying the stack and registers accordingly.\n     *\n     * @param {GPRState}                state     Array of register values\n     * @param {String|Number|NativePointer}           retAddr   Return address of the call to simulate.\n     * @param {StringArray|NumberArray} args      A variadic list of arguments.\n     */\n    simulateCall(state, retAddr, args) {\n        GPRState.validOrThrow(state);\n        retAddr = retAddr.toRword();\n        var fargs = this._formatVAArgs(args);\n        // Use this weird construction to work around a bug in the duktape runtime\n        var _simulateCall = function (a, b, c, d, e, f, g, h, i, j) {\n            QBDI_C.simulateCall(state.ptr, retAddr, fargs[0], a, b, c, d, e, f, g, h, i, j);\n        }\n        _simulateCall.apply(null, fargs[1]);\n    }\n\n    /**\n     * Use QBDI engine to retrieve loaded modules.\n     *\n     * @return list of module names (ex: [\"ls\", \"libc\", \"libz\"])\n     */\n    getModuleNames() {\n        var sizePtr = Memory.alloc(4);\n        var modsPtr = QBDI_C.getModuleNames(sizePtr);\n        var size = sizePtr.readU32();\n        if (modsPtr.isNull() || size === 0) {\n            return [];\n        }\n        var mods = [];\n        var p = modsPtr;\n        for (var i = 0; i < size; i++) {\n            var strPtr = p.readPointer();\n            var str = strPtr.readCString();\n            mods.push(str);\n            System.free(strPtr);\n            p = p.add(Process.pointerSize);\n        }\n        System.free(modsPtr);\n        return mods;\n    }\n\n    // Logs\n    setLogPriority(priority) {\n        QBDI_C.setLogPriority(priority);\n    }\n\n    // Helpers\n\n    /**\n     * This callback is displayed as part of the Requester class.\n     * @callback InstrRuleCallbackRaw\n     * @param {VM} vm\n     * @param {InstAnalysis} ana\n     * @param {*} data\n     */\n\n    /**\n     * Create a native **Instruction rule callback** from a JS function.\n     *\n     * Example:\n     *       >>> var icbk = vm.newInstrRuleCallback(function(vm, ana, data) {\n     *       >>>   console.log(\"0x\" + ana.address.toString(16) + \" \" + ana.disassembly);\n     *       >>>   return [new InstrRuleDataCBK(InstPosition.POSTINST, printCB, ana.disassembly)];\n     *       >>> });\n     *\n     * @param {InstrRuleCallbackRaw} cbk an instruction callback (ex: function(vm, ana, data) {};)\n     *\n     * @return an native InstrRuleCallback\n     */\n    newInstrRuleCallback(cbk) {\n        if (typeof (cbk) !== 'function' || cbk.length !== 3) {\n            return undefined;\n        }\n        // Use a closure to provide object\n        var vm = this;\n        var jcbk = function (vmPtr, anaPtr, cbksPtr, dataPtr) {\n            var ana = vm._parseInstAnalysis(anaPtr);\n            var data = vm._getUserData(dataPtr);\n            var res = cbk(vm, ana, data.userdata);\n            if (res === null) {\n                return;\n            }\n            if (!Array.isArray(res)) {\n                throw new TypeError('Invalid InstrRuleDataCBK Array');\n            }\n            if (res.length === 0) {\n                return;\n            }\n            for (var i = 0; i < res.length; i++) {\n                var d = vm._retainUserDataForInstrRuleCB2(res[i].data, data.id);\n                QBDI_C.addInstrRuleData(cbksPtr, res[i].position, res[i].cbk, d, res[i].priority);\n            }\n        }\n        return new NativeCallback(jcbk, 'void', ['pointer', 'pointer', 'pointer', 'pointer']);\n    }\n\n    /**\n     * This callback is displayed as part of the Requester class.\n     * @callback InstCallbackRaw\n     * @param {VM} vm\n     * @param {GPRState} gpr\n     * @param {FPRState} fpr\n     * @param {*} data\n     */\n\n    /**\n     * Create a native **Instruction callback** from a JS function.\n     *\n     * Example:\n     *       >>> var icbk = vm.newInstCallback(function(vm, gpr, fpr, data) {\n     *       >>>   inst = vm.getInstAnalysis();\n     *       >>>   console.log(\"0x\" + inst.address.toString(16) + \" \" + inst.disassembly);\n     *       >>>   return VMAction.CONTINUE;\n     *       >>> });\n     *\n     * @param {InstCallbackRaw} cbk an instruction callback (ex: function(vm, gpr, fpr, data) {};)\n     *\n     * @return an native InstCallback\n     */\n    newInstCallback(cbk) {\n        if (typeof (cbk) !== 'function' || cbk.length !== 4) {\n            return undefined;\n        }\n        // Use a closure to provide object\n        var vm = this;\n        var jcbk = function (vmPtr, gprPtr, fprPtr, dataPtr) {\n            var gpr = new GPRState(gprPtr);\n            var fpr = new FPRState(fprPtr);\n            var data = vm._getUserData(dataPtr);\n            return cbk(vm, gpr, fpr, data);\n        }\n        return new NativeCallback(jcbk, 'int', ['pointer', 'pointer', 'pointer', 'pointer']);\n    }\n\n    /**\n     * This callback is displayed as part of the Requester class.\n     * @callback VMCallbackRaw\n     * @param {VM} vm\n     * @param {VMState} state\n     * @param {GPRState} gpr\n     * @param {FPRState} fpr\n     * @param {*} data\n     */\n\n    /**\n     * Create a native **VM callback** from a JS function.\n     *\n     * Example:\n     *       >>> var vcbk = vm.newVMCallback(function(vm, evt, gpr, fpr, data) {\n     *       >>>   if (evt.event & VMEvent.EXEC_TRANSFER_CALL) {\n     *       >>>     console.warn(\"[!] External call to 0x\" + evt.basicBlockStart.toString(16));\n     *       >>>   }\n     *       >>>   return VMAction.CONTINUE;\n     *       >>> });\n     *\n     * @param {VMCallbackRaw} cbk a VM callback (ex: function(vm, state, gpr, fpr, data) {};)\n     *\n     * @return a native VMCallback\n     */\n    newVMCallback(cbk) {\n        if (typeof (cbk) !== 'function' || cbk.length !== 5) {\n            return undefined;\n        }\n        // Use a closure to provide object and a parsed event\n        var vm = this;\n        var jcbk = function (vmPtr, state, gprPtr, fprPtr, dataPtr) {\n            var s = vm._parseVMState(state);\n            var gpr = new GPRState(gprPtr);\n            var fpr = new FPRState(fprPtr);\n            var data = vm._getUserData(dataPtr);\n            return cbk(vm, s, gpr, fpr, data);\n        }\n        return new NativeCallback(jcbk, 'int', ['pointer', 'pointer', 'pointer', 'pointer', 'pointer']);\n    }\n\n    /**\n     * Call a function by its address (or through a Frida ``NativePointer``).\n     *\n     * Arguments can be provided, but their types need to be compatible\n     * with the ``.toRword()`` interface (like ``NativePointer`` or ``UInt64``).\n     *\n     * Example:\n     *       >>> var vm = new VM();\n     *       >>> var state = vm.getGPRState();\n     *       >>> var stackTopPtr = vm.allocateVirtualStack(state, 0x1000000);\n     *       >>> var aFunction = Module.findGlobalExportByName(\"Secret\");\n     *       >>> vm.addInstrumentedModuleFromAddr(aFunction);\n     *       >>> vm.call(aFunction, [42]);\n     *       >>> vm.alignedFree(stackTopPtr);\n     *\n     * @param {String|Number|NativePointer}           address function address (or Frida ``NativePointer``).\n     * @param {StringArray|NumberArray} [args]  optional list of arguments\n     */\n    call(address, args) {\n        address = address.toRword();\n        var fargs = this._formatVAArgs(args);\n        var vm = this.#vm;\n        // Use this weird construction to work around a bug in the duktape runtime\n        var _call = function (a, b, c, d, e, f, g, h, i, j) {\n            var retPtr = Memory.alloc(Process.pointerSize);\n            var res = QBDI_C.call(vm, retPtr, address, fargs[0], a, b, c, d, e, f, g, h, i, j);\n            if (res == false) {\n                throw new EvalError('Execution failed');\n            }\n            return ptr(retPtr.readRword());\n        }\n        return _call.apply(null, fargs[1]);\n    }\n\n    /**\n     * Call a function by its address (or through a Frida ``NativePointer``).\n     * QBDI will allocate his one stack to run, while the instrumented code will\n     * use the top of the current stack.\n     *\n     * Arguments can be provided, but their types need to be compatible\n     * with the ``.toRword()`` interface (like ``NativePointer`` or ``UInt64``).\n     *\n     * Example:\n     *       >>> var vm = new VM();\n     *       >>> var state = vm.getGPRState();\n     *       >>> var aFunction = Module.findGlobalExportByName(\"Secret\");\n     *       >>> vm.addInstrumentedModuleFromAddr(aFunction);\n     *       >>> vm.switchStackAndCall(aFunction, [42]);\n     *\n     * @param {String|Number|NativePointer}           address function address (or Frida ``NativePointer``).\n     * @param {StringArray|NumberArray} [args]  optional list of arguments\n     * @param {String|Number}           [stackSize] stack size for the engine.\n     */\n    switchStackAndCall(address, args, stackSize) {\n        if (stackSize === null || stackSize === undefined) {\n            stackSize = 0x20000;\n        }\n        address = address.toRword();\n        var fargs = this._formatVAArgs(args);\n        var vm = this.#vm;\n        // Use this weird construction to work around a bug in the duktape runtime\n        var _scall = function (a, b, c, d, e, f, g, h, i, j) {\n            var retPtr = Memory.alloc(Process.pointerSize);\n            var res = QBDI_C.switchStackAndCall(vm, retPtr, address, stackSize, fargs[0], a, b, c, d, e, f, g, h, i, j);\n            if (res == false) {\n                throw new EvalError('Execution failed');\n            }\n            return ptr(retPtr.readRword());\n        }\n        return _scall.apply(null, fargs[1]);\n    }\n\n    ////////////////////\n    // private method //\n    ////////////////////\n\n    _parseStructDesc(ptr) {\n        var desc = {};\n        desc.size = ptr.readU32();\n        ptr = ptr.add(4);\n        desc.items = ptr.readU32();\n        ptr = ptr.add(4);\n        desc.offsets = [];\n        for (var i = 0; i < desc.items; i++) {\n            var offset = ptr.readU32();\n            ptr = ptr.add(4);\n            desc.offsets.push(offset);\n        }\n        Object.freeze(desc);\n        return desc;\n    }\n\n    _initVM() {\n        var vmPtr = Memory.alloc(Process.pointerSize);\n        QBDI_C.initVM(vmPtr, NULL, NULL, 0);\n        return vmPtr.readPointer();\n    }\n\n    _terminateVM(v) {\n        QBDI_C.terminateVM(v);\n    }\n\n\n    // Retain (~reference) a user data object when an instrumentation is added.\n    //\n    // If a ``NativePointer`` is given, it will be used as raw user data and the\n    // object will not be retained.\n    _retainUserData(data, fn) {\n        var dataPtr = ptr(\"0\");\n        var managed = false;\n        if (data !== null && data !== undefined) {\n            this.#userDataPointer += 1;\n            dataPtr = dataPtr.add(this.#userDataPointer);\n            managed = true;\n        }\n        var iid = fn(dataPtr);\n        if (managed) {\n            this.#userDataPtrMap[dataPtr] = data;\n            this.#userDataIIdMap[iid] = dataPtr;\n        }\n        return iid;\n    }\n\n    _retainUserDataForInstrRuleCB(data, fn) {\n        this.#userDataPointer += 1;\n        var dataPtr = ptr(\"0\").add(this.#userDataPointer);\n\n        var iid = fn(dataPtr);\n\n        this.#userDataPtrMap[dataPtr] = { userdata: data, id: iid };\n        this.#userDataIIdMap[iid] = [dataPtr];\n        return iid;\n    }\n\n    _retainUserDataForInstrRuleCB2(data, id) {\n        if (data !== null && data !== undefined) {\n            this.#userDataPointer += 1;\n            var dataPtr = ptr(\"0\").add(this.#userDataPointer);\n\n            this.#userDataPtrMap[dataPtr] = data;\n            this.#userDataIIdMap[id].push(dataPtr);\n            return dataPtr;\n        } else {\n            return ptr(\"0\");\n        }\n    }\n\n    // Retrieve a user data object from its ``NativePointer`` reference.\n    // If pointer is NULL or no data object is found, the ``NativePointer``\n    // object will be returned.\n    _getUserData(dataPtr) {\n        var data = dataPtr;\n        if (!data.isNull()) {\n            var d = this.#userDataPtrMap[dataPtr];\n            if (d !== undefined) {\n                return d;\n            }\n        }\n        return undefined;\n    }\n\n    // Release references to a user data object using the correponding\n    // instrumentation id.\n    _releaseUserData(id) {\n        var dataPtr = this.#userDataIIdMap[id];\n        if (dataPtr !== undefined) {\n            if (Array.isArray(dataPtr)) {\n                for (var i = 0; i < dataPtr.length; i++) {\n                    delete this.#userDataPtrMap[dataPtr[i]];\n                }\n            } else {\n                delete this.#userDataPtrMap[dataPtr];\n            }\n            delete this.#userDataIIdMap[id];\n        }\n    }\n\n    // Release all references to user data objects.\n    _releaseAllUserData() {\n        this.#userDataPtrMap = {};\n        this.#userDataIIdMap = {};\n        this.#userDataPointer = 0;\n    }\n\n    _formatVAArgs(args) {\n        if (args === undefined) {\n            args = [];\n        }\n        var argsCnt = args.length;\n        // We are limited to 10 arguments for now\n        var fargs = new Array(10);\n        var fargsCnt = fargs.length\n        for (var i = 0; i < fargsCnt; i++) {\n            if (i < argsCnt) {\n                fargs[i] = args[i].toRword();\n            } else {\n                fargs[i] = 0;\n            }\n        }\n        return [argsCnt, fargs];\n    }\n\n\n    /**\n     * @typedef {Object} MemoryAccess\n     * @property {number} instAddress\n     * @property {number} accessAddress\n     * @property {number} value\n     * @property {number} size\n     * @property {number} type\n     * @property {number} flags\n     */\n\n    /**\n     * @param {*} ptr\n     * @returns {MemoryAccess}\n     */\n    _parseMemoryAccess(ptr) {\n        var access = {};\n        var p = ptr.add(this.#instAnalysisStructDesc.offsets[0]);\n        access.instAddress = p.readRword();\n        p = ptr.add(this.#memoryAccessDesc.offsets[1]);\n        access.accessAddress = p.readRword();\n        p = ptr.add(this.#memoryAccessDesc.offsets[2]);\n        access.value = p.readRword();\n        p = ptr.add(this.#memoryAccessDesc.offsets[3]);\n        access.size = p.readU16();\n        p = ptr.add(this.#memoryAccessDesc.offsets[4]);\n        access.type = p.readU8();\n        p = ptr.add(this.#memoryAccessDesc.offsets[5]);\n        access.flags = p.readU8();\n        Object.freeze(access);\n        return access;\n    }\n\n    _getMemoryAccess(f) {\n        var accesses = [];\n        var sizePtr = Memory.alloc(4);\n        var accessPtr = f(this.#vm, sizePtr);\n        if (accessPtr.isNull()) {\n            return [];\n        }\n        var cnt = sizePtr.readU32();\n        var sSize = this.#memoryAccessDesc.size;\n        var p = accessPtr;\n        for (var i = 0; i < cnt; i++) {\n            var access = this._parseMemoryAccess(p);\n            accesses.push(access);\n            p = p.add(sSize);\n        }\n        System.free(accessPtr);\n        return accesses;\n    }\n\n    /**\n     * @typedef {Object} VMState\n     * @property {number} event\n     * @property {number} sequenceStart\n     * @property {number} sequenceEnd\n     * @property {number} basicBlockStart\n     * @property {number} basicBlockEnd\n     * @property {number} lastSignal\n     */\n\n    /**\n     * @param {*} ptr\n     * @returns {VMState}\n     */\n    _parseVMState(ptr) {\n        var state = {};\n        var p = ptr.add(this.#instAnalysisStructDesc.offsets[0]);\n        state.event = p.readU8();\n        p = ptr.add(this.#vmStateStructDesc.offsets[1]);\n        state.sequenceStart = p.readRword();\n        p = ptr.add(this.#vmStateStructDesc.offsets[2]);\n        state.sequenceEnd = p.readRword();\n        p = ptr.add(this.#vmStateStructDesc.offsets[3]);\n        state.basicBlockStart = p.readRword();\n        p = ptr.add(this.#vmStateStructDesc.offsets[4]);\n        state.basicBlockEnd = p.readRword();\n        p = ptr.add(this.#vmStateStructDesc.offsets[5]);\n        state.lastSignal = p.readRword();\n        Object.freeze(state);\n        return state;\n    }\n\n    /**\n     * @typedef {Object} OperandAnalysis\n     * @property {number} type\n     * @property {number} flag\n     * @property {number} value\n     * @property {number} size\n     * @property {number} regOff\n     * @property {number} regCtxIdx\n     * @property {string|null} regName\n     * @property {number} regAccess\n     */\n\n    /**\n     * @param {*} ptr\n     * @returns {OperandAnalysis}\n     */\n    _parseOperandAnalysis(ptr) {\n        var analysis = {};\n        var p = ptr.add(this.#instAnalysisStructDesc.offsets[0]);\n        analysis.type = p.readU32();\n        p = ptr.add(this.#operandAnalysisStructDesc.offsets[1]);\n        analysis.flag = p.readU8();\n        p = ptr.add(this.#operandAnalysisStructDesc.offsets[2]);\n        analysis.value = p.readSword();\n        p = ptr.add(this.#operandAnalysisStructDesc.offsets[3]);\n        analysis.size = p.readU8();\n        p = ptr.add(this.#operandAnalysisStructDesc.offsets[4]);\n        analysis.regOff = p.readU8();\n        p = ptr.add(this.#operandAnalysisStructDesc.offsets[5]);\n        analysis.regCtxIdx = p.readS16();\n        p = ptr.add(this.#operandAnalysisStructDesc.offsets[6]);\n        var regNamePtr = p.readPointer();\n        if (regNamePtr.isNull()) {\n            analysis.regName = undefined;\n        } else {\n            analysis.regName = regNamePtr.readCString();\n        }\n        p = ptr.add(this.#operandAnalysisStructDesc.offsets[7]);\n        analysis.regAccess = p.readU8();\n        Object.freeze(analysis);\n        return analysis;\n    }\n\n    /**\n     * @typedef {Object} InstAnalysis\n     * @property {string|null} mnemonic\n     * @property {string|null} disassembly\n     * @property {number} address\n     * @property {number} instSize\n     * @property {boolean} affectControlFlow\n     * @property {boolean} isBranch\n     * @property {boolean} isCall\n     * @property {boolean} isReturn\n     * @property {boolean} isCompare\n     * @property {boolean} isPredicable\n     * @property {boolean} isMoveImm\n     * @property {boolean} mayLoad\n     * @property {boolean} mayStore\n     * @property {number} loadSize\n     * @property {number} storeSize\n     * @property {number} condition\n     * @property {number} flagsAccess\n     * @property {Array<OperandAnalysis>} operands\n     * @property {string|null} symbolName\n     * @property {string|null} symbol\n     * @property {number} symbolOffset\n     * @property {string|null} moduleName\n     * @property {string|null} module\n     * @property {string|null} cpuMode\n     * @property {number} patchSize\n     * @property {number} patchInstOffset\n     * @property {number} patchInstSize\n     * @property {number} analysisType\n     */\n\n    /**\n     * @param {*} ptr\n     * @returns {InstAnalysis}\n     */\n    _parseInstAnalysis(ptr) {\n        var analysis = {};\n        var p = ptr.add(this.#instAnalysisStructDesc.offsets[27]);\n        var analysisType = p.readU16();\n\n        if ((analysisType & AnalysisType.ANALYSIS_INSTRUCTION) != 0) {\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[0]);\n          analysis.mnemonic = p.readPointer().readCString();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[2]);\n          analysis.address = p.readRword();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[3]);\n          analysis.instSize = p.readU32();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[4]);\n          analysis.affectControlFlow = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[5]);\n          analysis.isBranch = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[6]);\n          analysis.isCall = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[7]);\n          analysis.isReturn = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[8]);\n          analysis.isCompare = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[9]);\n          analysis.isPredicable = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[10]);\n          analysis.isMoveImm = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[11]);\n          analysis.mayLoad = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[12]);\n          analysis.mayStore = p.readU8() == true;\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[13]);\n          analysis.loadSize = p.readU32();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[14]);\n          analysis.storeSize = p.readU32();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[15]);\n          analysis.condition = p.readU8();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[22]);\n          analysis.cpuMode = p.readU8();\n        }\n        if ((analysisType & AnalysisType.ANALYSIS_DISASSEMBLY) != 0) {\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[1]);\n          analysis.disassembly = p.readPointer().readCString();\n        }\n        if ((analysisType & AnalysisType.ANALYSIS_OPERANDS) != 0) {\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[16]);\n          analysis.flagsAccess = p.readU8();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[17]);\n          var numOperands = p.readU8();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[18]);\n          var operandsPtr = p.readPointer();\n          analysis.operands = new Array(numOperands);\n          for (var i = 0; i < numOperands; i++) {\n              analysis.operands[i] = this._parseOperandAnalysis(operandsPtr);\n              operandsPtr = operandsPtr.add(this.#operandAnalysisStructDesc.size);\n          }\n        }\n        if ((analysisType & AnalysisType.ANALYSIS_SYMBOL) != 0) {\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[19]);\n          var symbolPtr = p.readPointer();\n          if (!symbolPtr.isNull()) {\n              analysis.symbolName = symbolPtr.readCString();\n          } else {\n              analysis.symbolName = \"\";\n          }\n          analysis.symbol = analysis.symbolName; // deprecated Name\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[20]);\n          analysis.symbolOffset = p.readU32();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[21]);\n          var modulePtr = p.readPointer();\n          if (!modulePtr.isNull()) {\n              analysis.moduleName = modulePtr.readCString();\n          } else {\n              analysis.moduleName = \"\";\n          }\n          analysis.module = analysis.moduleName; // deprecated Name\n        }\n        if ((analysisType & AnalysisType.ANALYSIS_JIT) != 0) {\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[23]);\n          analysis.patchAddress = p.readRword();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[24]);\n          analysis.patchSize = p.readU16();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[25]);\n          analysis.patchInstOffset = p.readU16();\n          p = ptr.add(this.#instAnalysisStructDesc.offsets[26]);\n          analysis.patchInstSize = p.readU16();\n        }\n\n        Object.freeze(analysis);\n        return analysis;\n    }\n\n};\n\n\n\n//# sourceURL=webpack:///./qbdi/frida-qbdi.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _qbdi_frida_qbdi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../qbdi/frida-qbdi.js */ \"./qbdi/frida-qbdi.js\");\nconst { log, print_stack, print_memory, print_jobject } = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\r\n\r\n\r\n\r\nJava.perform(function () {\r\n    hook_android_dlopen_ext();\r\n});\r\n\r\nfunction hook_native_main()\r\n{\r\n    //  ShellBridge \r\n    var ShellBridge = Java.use('com.meituan.android.common.mtguard.ShellBridge');\r\n\r\n    // Hook main \r\n    ShellBridge.main.overload('int', '[Ljava.lang.Object;').implementation = function (i, objArr) {\r\n        console.log('args: ', i);\r\n        print_jobject(objArr)\r\n        var result = this.main(i, objArr);\r\n        console.log('return: ', result);\r\n        return result;\r\n    };\r\n}\r\n\r\nfunction hook_android_dlopen_ext()\r\n{\r\n    let android_dlopen_ext_func_addr = Module.findExportByName(null, \"android_dlopen_ext\");\r\n    if (android_dlopen_ext_func_addr) {\r\n        Interceptor.attach(android_dlopen_ext_func_addr, {\r\n            onEnter(args) {\r\n                let pathptr = args[0];\r\n                if (pathptr !== undefined && pathptr != null) {\r\n                    this.path = ptr(pathptr).readCString();\r\n                    log(\"android_dlopen_ext\", this.path);\r\n                    if (this.path.endsWith(\"libmtguard.so\"))\r\n                    {\r\n                        setTimeout(hook_libmtguard_main, 10); \r\n                    }\r\n                }\r\n            },\r\n            onLeave(ret) {\r\n\r\n            }\r\n        });\r\n    } else {\r\n        log(\"android_dlopen_ext not found\");\r\n    }\r\n}\r\nfunction hook_libmtguard_main() {\r\n    let libmtguard_base = Module.getBaseAddress(\"libmtguard.so\");\r\n    console.log(\"libmtguard.so address: \", libmtguard_base);\r\n    \r\n    let target_address;\r\n\r\n    // for (let address of [0x25df0, 0x2653c, 0x268c8, 0x26aa4, 0x26c78])\r\n    // {\r\n    //     target_address = libmtguard_base.add(address);\r\n    //     console.log(\"[+] Hooking function at: \" + target_address);\r\n    //     Interceptor.attach(target_address, {\r\n    //         onEnter: function (args) {\r\n    //             console.log(\" \", address.toString(16), this.context.x20);\r\n    //         },\r\n    //     });\r\n    // }\r\n\r\n\r\n    // target_address = libmtguard_base.add(0x26530);\r\n    // console.log(\"[+] Hooking function at: \" + target_address);\r\n    // Interceptor.attach(target_address, {\r\n    //     onEnter: function (args) {\r\n    //         console.log(\": \", this.context.x0, this.context.x1);\r\n    //         let javaObject = Java.cast(this.context.x1, Java.use('java.lang.Object')); \r\n    //         print_jobject(javaObject)\r\n    //     },\r\n    // });\r\n\r\n    // target_address = libmtguard_base.add(0x3E254);\r\n    // console.log(\"[+] Hooking function at: \" + target_address);\r\n    // Interceptor.attach(target_address, {\r\n    //     onEnter: function (args) {\r\n    //         console.log(\": \", this.context.x0, this.context.x1, this.context.x2, this.context.x3);\r\n    //         console.log(\"findModuleByAddress\", this.context.x8)\r\n    //     },\r\n    // });0x7455492000\r\n\r\n    target_address = libmtguard_base.add(0x25D2C);\r\n    console.log(\"[+] Hooking function at: \" + target_address);\r\n    Interceptor.attach(target_address, {\r\n        onEnter: function (args) {\r\n            console.log(\": \", this.context.x0, this.context.x1, this.context.x2, this.context.x3);\r\n            let javaObject = Java.cast(this.context.x3, Java.use('java.lang.Object')); \r\n            trace_libmtguard(this.context.x0, this.context.x1, this.context.x2, this.context.x3)\r\n        },\r\n    });\r\n\r\n}\r\n\r\n\r\n\r\nfunction trace_libmtguard(...args)\r\n{\r\n    var vm = new _qbdi_frida_qbdi_js__WEBPACK_IMPORTED_MODULE_0__.VM();\r\n    var state = vm.getGPRState();\r\n    var stack = vm.allocateVirtualStack(state, 0x100000);\r\n\r\n    let libmtguard_module = Process.findModuleByName(\"libmtguard.so\");\r\n    console.log(\"libmtguard.so: \", libmtguard_module.base);\r\n    \r\n    vm.addInstrumentedRange(libmtguard_module.base, libmtguard_module.base.add(libmtguard_module.size));\r\n\r\n    var icbk = vm.newInstCallback(function(vm, gpr, fpr, data) {\r\n        var inst = vm.getInstAnalysis();\r\n        // gpr.dump(); // Display context\r\n        console.log(\"0x\" + inst.address.toString(16) + \" \" + inst.disassembly); // Display instruction dissassembly\r\n        return _qbdi_frida_qbdi_js__WEBPACK_IMPORTED_MODULE_0__.VMAction.CONTINUE;\r\n    });\r\n\r\n    var iid = vm.addCodeCB(_qbdi_frida_qbdi_js__WEBPACK_IMPORTED_MODULE_0__.InstPosition.PREINST, icbk);\r\n\r\n    var result = vm.call(libmtguard_module.base.add(0x25D2C), args);\r\n    console.log(\":\", result);\r\n    if (result != 0x0)\r\n    {\r\n        console.log(\":\", result);\r\n        let javaObject = Java.cast(result, Java.use('java.lang.Object')); \r\n        print_jobject(javaObject)\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((module) => {

eval("function log(label) {\r\n  const args = Array.from(arguments).slice(1);\r\n  const message = args.map(arg => \r\n    typeof arg === 'string' ? arg : JSON.stringify(arg)\r\n  ).join(' ');\r\n  \r\n  console.log(`[${label}] ${message}`);\r\n}\r\n\r\nfunction print_stack(name) {\r\n    Java.perform(function () {\r\n        var Exception = Java.use(\"java.lang.Exception\");\r\n        var ins = Exception.$new(\"Exception\");\r\n        var straces = ins.getStackTrace();\r\n        if (straces != undefined && straces != null) {\r\n            var strace = straces.toString();\r\n            var replaceStr = strace.replace(/,/g, \"\\n\");\r\n            console.log(\"=============================\" + name + \" Stack strat=======================\");\r\n            console.log(replaceStr);\r\n            console.log(\"=============================\" + name + \" Stack end=======================\\r\\n\");\r\n            Exception.$dispose();\r\n        }\r\n    });\r\n}\r\n\r\nfunction print_memory(address, length=64) {\r\n    console.log(hexdump(address, {\r\n        offset: 0,\r\n        length: length,\r\n        header: true,\r\n        ansi: true,\r\n    }));\r\n}\r\n\r\nfunction print_jobject(jobject, can_print_fields=false, can_print_methods=false)\r\n{\r\n    let className = jobject.getClass().getName(); \r\n    console.log(`${className} -> `, jobject.toString());\r\n\r\n    if (can_print_fields)\r\n    {\r\n        // \r\n        let fields = jobject.getClass().getDeclaredFields();\r\n        for (let field of fields) {\r\n            field.setAccessible(true); // \r\n            let fieldName = field.getName();\r\n            let fieldValue = field.get(jobject);\r\n            console.log('  Field:', fieldName, 'Value:', fieldValue);\r\n        }\r\n    }\r\n\r\n    if (can_print_methods)\r\n    {\r\n        // \r\n        let methods = jobject.getClass().getDeclaredMethods();\r\n        for (let method of methods) {\r\n            method.setAccessible(true); // \r\n            let methodName = method.getName();\r\n            console.log('  Method:', methodName);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = { log, print_stack, print_memory, print_jobject };\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;